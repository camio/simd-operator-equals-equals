---
title: "`std::simd` Types Should be Value Semantic"
document: D2892R0
date: 2023-05-16
audience: Library Evolution
author:
  - name: Joe Jevnik
    email: <joejev@gmail.com>
  - name: David Sankel
    email: <dsankel@adobe.com>
toc: false

---

# Abstract

SIMD Types from the Parallelism TS are proposed for adoption in C++26. Deviating
from standard value-semantic types, the `==` operator for SIMD types returns a
mask instead of `bool`. This inconsistency detrimentally effects user
experience. We instead recommend that `==` and related operators return `bool`
with masked variants provided as free functions.

::: cmptable

### Before

```cpp
using uint32_4v = std::fixed_size_simd<std::uint32_t, 4>;

class Color {
public:
  bool operator==(const SimdColor &) const = default;
private:
  uint32_4v data_;
};

void f() {
  Color a, b;
  // ...
  if( a == b )         // ERROR: use of deleted function 'Color::operator=='
     //...
}
```

### After

```cpp
using uint32_4v = std::fixed_size_simd<std::uint32_t, 4>;

class Color {
public:
  bool operator==(const SimdColor &) const = default;
private:
  uint32_4v data_;
};

void f() {
  Color a, b;
  // ...
  if( a == b )         // OKAY
     //...
}
```

:::

# Introduction

The Parallelism TS 2, @N4808, includes data-parallel types that enable the
portable utilization of "single instruction, multiple data" (SIMD) CPU
capabilities. Matthias Kretz proposes standardizing these types with some
modifications (hereafter referred to as `std::simd`) in @P1928R3, "Merge
Data-Parallel Types From the Parallelism TS 2". This initiative prompted working
sessions at C++Now 2023 that analyzed `std::simd` from a usability perspective.

Notably, the behavior and return type of `==` for `simd` types was discussed. As
currently defined, `==` performs element-wise equality and returns a `simd_mask`
of the result. Given `simd` objects `v1` and `v2` with values `1,2,3,4` and
`1,4,3,6`, `v1 == v2` has value `1,0,1,0`. This is consistent with other `simd`
operators such as `+`, `-`, `*`, and `/`.

While this behavior appears promising, it runs contrary to long established
convention with value semantic types in C++. The departure results in increased
complexity and unexpected behavior in user code. After lengthy discussions, a
poll was taken at C++Now indicating a strong preference for conventional `==`
semantics for `simd` types:

*operator== should return a scalar bool*

| SF | F  | N | A | SA |
| -- | -- | - | - | -- |
| 9  | 10 | 0 | 1 |  0 |

In the following sections we outline the arguments leading to this result by
reviewing value semantics, considering its application to `std::simd` types, and
looking at existing practices.

# Value semantics and its advantages

Objects of value types correspond to mathematical entities, enabling equational
reasoning. This correspondence is the basis of generic programming, which allows
algorithms to be composed and reused without modification in different
scenarios. For a full treatment, see @EOP.

To take full advantage of value types, they need to be consistently rendered in
code. In C++, properly encoded value types are called regular. @DeSt98 calls out
the following relationships for the copy constructor, assignment, and equality:

1. `T a = b; assert(a==b);`
2. `T a; a = b;` â‡” `T a = b;`
3. `T a = c; T b = c; a = d; assert(b==c)`
4. `T a = c; T b = c; zap(a); assert(b==c && a!=b)` where `zap` always changes
   its operand's value.

Due to the consistent rendering regular types can be easily composed into more
sophisticated regular types. In the following snippet, `S` is, by construction,
a regular type if `T1` and `T2` are:

```c++
struct S {
  T1 o1;
  T2 o2;
  bool operator==(const S&) const = default;
}
```

The standard library also heavily depends on value semantic types being regular.
`std::find(first, last, value)`, for example, uses the `==` operator to search
for `value` in the `[first,last)` range.

Due to readability and productivity benefits, regular rendering of value
semantic types are a best practice for C++ as reflected by several C++ Core
Guidelines rules (See @CppCoreGuidelines):

- [C.11](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-regular)
  "Regular types are easier to understand and reason about than types that are
  not regular...Concrete classes without assignment and equality can be
  defined, but they are (and should be) rare."
- [C.61](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-copy)
  "After `x=y`, we should have `x == y`"
- [C.160](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#SS-overload)
  "Define operators primarily to mimic conventional usage"

# std::simd types and value semantics

- Provide the two examples
- Show frustration at failure points

# Existing practice

There exists many libraries which wrap SIMD operations today.
Some libraries more explicitly wrap a single SIMD register, like VCL or xsimd,  where others express larger arrays or mathematical objects.
The following table covers some open source libraries and their choices with respect to comparison operators.

| Library                            | Comparison Behavior                                              |
| ---------------------------------- | ---------------------------------------------------------------- |
| Armadillo                          | Element-wise                                                     |
| Blaze                              | Regular                                                          |
| EVE                                | Element-wise                                                     |
| Eigen::Array                       | Element-wise                                                     |
| Eigen::{Matrix, RowVector, Vector} | Regular                                                          |
| Fastor                             | Element-wise                                                     |
| VCL                                | Element-wise                                                     |
| xsimd                              | Element-wise                                                     |
| xtensor                            | Regular `operator==` and `operator!=`; rest are element-wise[^1] |

## Wrappers and DSLs

These libraries exist broadly in two categories: wrappers around SIMD operations and DSLs (domain specific languages) for doing math and multidimensional array operations.
For libraries that are conceptually DSLs: users are unlikely to switch away from these high level tools.
If end users want to use a DSL, they will be shielded from the particular syntactic choices used by `std::simd` and this is an irrelevant decision for them.

For users who want to introduce a small amount of data parallelism in their code, or are implementers of a DSL, having regular comparison will fit more naturally into rest of the C++ language for the reasons stated above.
Non-DSL users will still see a considerable benefit with respect to conciseness and clarity over using platform specific intrinsic operations, even with value-semantics.
For example if we compare one of the algorithms in [@P1928R3] which used element-wise `operator>=`, the new proposal is not considerably more verbose nor unclear:

```diff
 using floatv = std::simd<float>
 using intv = std::rebind_simd_t<int, floatv>;

 int count_positive(const std::vector<floatv>& xs) {
     // simplify generated assembly:
     if (x.size() == 0) std::unreachable();
     intv counter = {};
     for (std::simd x : xs) {
-        counter += x > 0;
+        counter += @_greater_@(x, 0);
     }
     return reduce(counter);
 }
```

# Conclusion

Stuffies...

[^1]: This option is only used in xtensor, not even the related project xsimd.
      The inconsistency seems more likely to cause bugs than selecting either behavior by itself.

# TODO

Incoporate?


---
references:
  - id: P1928R3
    citation-label: P1928R3
    title: "Merge Data-Parallel Types From the Parallelism TS 2"
    author:
      - family: Kretz
        given: Matthias
    issued:
      year: 2023
    url: http://wg21.link/P1928R3
  - id: N4808
    citation-label: N4808
    title: "Working Draft, C++ Extensions for Parallelism Version 2"
    author:
      - family: Jared
        given: Hoberock
    issued:
      year: 2019
    url: http://wg21.link/N4808
  - id: ValueSemantics
    citation-label: ValueSemantics
    title: "Value semantics"
    author:
      - family: Wikipedia contributors
        given: 
    issued:
      year: 2023
    url: https://en.wikipedia.org/wiki/Value_semantics
  - id: EOP
    citation-label: EOP
    title: "Elements of Programming"
    author:
      - family: Stepanov
        given: Alexander
      - family: McJones
        given: Paul
    issued:
      year: 2009
    publisher: Addison-Wesley Professional
    url: http://elementsofprogramming.com/eop.pdf
  - id: DeSt98
    citation-label: DeSt98
    title: "Fundamentals of Generic Programming"
    author:
      - family: Dehnert
        given: James C.
      - family: Stepanov
        given: Alexander
    issued:
      year: 1998
    publisher: Addison-Wesley Professional
    url: http://stepanovpapers.com/DeSt98.pdf
  - id: CppCoreGuidelines
    citation-label: CppCoreGuidelines
    title: "C++ Core Guidelines"
    author:
      - family: Stroustrup
        given: Bjarne
      - family: Sutter
        given: Herb
    issued:
      year: 2020
    url: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
---
