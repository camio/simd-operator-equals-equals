---
title: "`std::simd` Types Should be Value Semantic"
document: D2892R0
date: 2023-05-16
audience: Library Evolution
author:
  - name: Joe Jevnik
    email: <joejev@gmail.com>
  - name: David Sankel
    email: <dsankel@adobe.com>
toc: false

---

# Abstract

SIMD Types from the Parallelism TS are proposed for adoption in C++26. Deviating
from standard value-semantic types, the `==` operator for SIMD types returns a
mask instead of `bool`. This inconsistency detrimentally effects user
experience. We instead recommend that `==` and related operators return `bool`
with masked variants provided as free functions.

::: cmptable

### Before

```cpp
using uint32_4v = std::fixed_size_simd<std::uint32_t, 4>;

class Color {
public:
  bool operator==(const SimdColor &) const = default;
private:
  uint32_4v data_;
};

void f() {
  Color a, b;
  // ...
  if( a == b )         // ERROR: use of deleted function 'Color::operator=='
     //...
}
```

### After

```cpp
using uint32_4v = std::fixed_size_simd<std::uint32_t, 4>;

class Color {
public:
  bool operator==(const SimdColor &) const = default;
private:
  uint32_4v data_;
};

void f() {
  Color a, b;
  // ...
  if( a == b )         // OKAY
     //...
}
```

:::

# Introduction

Set context:

- std::simd being proposed for standardization
- Point out benefits of value semantics for std::simd types
- Point out status quo that we are trying to change

## C++Now discussion

At the C++Now conference held from May 9th through May 12th, `std::simd` was discussed during the library in a week session.
During this discussion, there were originally arguments both in favor of element-wise comparison and value-semantics.
The C++Now discussion led us to collect the existing practice table and present pros and cons to each approach.
Once all of the arguments were presented, we took the straw poll: "std::simd operator== return a scalar bool"

|SF| F| N| A|SA|
|--|--|--|--|--|
| 9|10| 0| 1| 0|

# Value semantics and its advantages

- Introduce value semantics
- Discuss C++ rendering
- Discuss advantages of uniform treatment

## Integration with defaulted `operator==` and `operator<=>`

Imagine a user has written the following classes and would like to accelerate them using `std::simd`:

```c++
struct Pixel {
    std::uint32_t red = 0;
    std::uint32_t green= 0;
    std::uint32_t blue = 0;
    std::uint32_t alpha = 0;

    bool operator==(const Pixel&) const = default;
};
```

Here, a user might try to write something like:

```c++
struct Pixel {
    std::simd<std::uint32_t> value{};

    std::uint32_t red() const;
    std::uint32_t green() const;
    std::uint32_t blue() const;
    std::uint32_t alpha() const;

    bool operator==(const Pixel&) const = default;  // error, cannot provide default
};
```

Making comparisons element-wise will undo the benefits of introducing defaulted `operator==` and `operator<=>` to the language and force users to write trivial implementations of these functions for every structure that embeds a `std::simd`.


# std::simd types and value semantics

- Provide the two examples
- Show frustration at failure points

# Existing practice

There exists many libraries which wrap SIMD operations today.
Some libraries more explicitly wrap a single SIMD register, like VCL or xsimd,  where others express larger arrays or mathematical objects.
The following table covers some open source libraries and their choices with respect to comparison operators.

| Library                            | Comparison Behavior                                              |
| ---------------------------------- | ---------------------------------------------------------------- |
| Armadillo                          | Element-wise                                                     |
| Blaze                              | Regular                                                          |
| EVE                                | Element-wise                                                     |
| Eigen::Array                       | Element-wise                                                     |
| Eigen::{Matrix, RowVector, Vector} | Regular                                                          |
| Fastor                             | Element-wise                                                     |
| VCL                                | Element-wise                                                     |
| xsimd                              | Element-wise                                                     |
| xtensor                            | Regular `operator==` and `operator!=`; rest are element-wise[^1] |

## Wrappers and DSLs

These libraries exist broadly in two categories: wrappers around SIMD operations and DSLs (domain specific languages) for doing math and multidimensional array operations.
For libraries that are conceptually DSLs: users are unlikely to switch away from these high level tools.
If end users want to use a DSL, they will be shielded from the particular syntactic choices used by `std::simd` and this is an irrelevant decision for them.

For users who want to introduce a small amount of data parallelism in their code, or are implementers of a DSL, having regular comparison will fit more naturally into rest of the C++ language for the reasons stated above.
Non-DSL users will still see a considerable benefit with respect to conciseness and clarity over using platform specific intrinsic operations, even with value-semantics.
For example if we compare one of the algorithms in [@P1928R3] which used element-wise `operator>=`, the new proposal is not considerably more verbose nor unclear:

```diff
 using floatv = std::simd<float>
 using intv = std::rebind_simd_t<int, floatv>;

 int count_positive(const std::vector<floatv>& xs) {
     // simplify generated assembly:
     if (x.size() == 0) std::unreachable();
     intv counter = {};
     for (std::simd x : xs) {
-        counter += x > 0;
+        counter += @_greater_@(x, 0);
     }
     return reduce(counter);
 }
```

# Conclusion

Stuffies...

[^1]: This option is only used in xtensor, not even the related project xsimd.
      The inconsistency seems more likely to cause bugs than selecting either behavior by itself.

# TODO

Reference parallelism TS n4808

wg21.link/n4808

---
references:
  - id: P1928R3
    citation-label: P1928R3
    title: "Merge Data-Parallel Types From the Parallelism TS 2"
    author:
      - family: Kretz
        given: Matthias
    issued:
      year: 2023
    url: http://wg21.link/P1928R3
---
